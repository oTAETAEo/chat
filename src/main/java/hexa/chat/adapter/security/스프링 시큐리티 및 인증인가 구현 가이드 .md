# 스프링 시큐리티 및 인증/인가 구현 가이드

본 문서는 **헥사고날 아키텍처(Hexagonal Architecture)**와 **DDD(Domain-Driven Design)** 원칙을 준수하며, 안전하고 확장 가능한 인증 시스템을 구축하기 위한 상세 가이드입니다.

---

## 1. 아키텍처 핵심 원칙

1.  **Security as an Adapter**: 보안 기술(Spring Security, JWT 등)은 비즈니스 로직이 아닌, 외부 요청을 처리하는 **인바운드 어댑터**이자 인프라입니다.
2.  **Application Purity**: `AuthService` 등 애플리케이션 계층은 `AuthenticationManager`, `SecurityContext` 등 프레임워크 종속적인 클래스에 의존하지 않아야 합니다.
3.  **Multi-Device Login**: 하나의 계정으로 여러 기기(Web, Mobile 등)에서 동시 로그인이 가능하도록 **Refresh Token을 1:N 관계**로 관리합니다.

---

## 2. 구현 로드맵 (Step-by-Step)

### Step 1: 의존성 추가
`build.gradle`에 Security 및 JWT 관련 라이브러리를 추가합니다.

### Step 2: 도메인 & 포트 정의 (Application Layer)
비즈니스 로직이 사용할 인터페이스를 먼저 정의합니다.

#### 1. Inbound Port (Provided)
외부(Web, CLI)에서 호출할 기능을 정의합니다.
- `LoginUseCase`: 로그인 요청 처리 (로그인 -> Access/Refresh Token 반환)
- `TokenReissueUseCase`: 토큰 재발급 요청 처리 (Refresh Token -> Access Token 재발급)

#### 2. Outbound Port (Required)
비즈니스 로직이 필요로 하는 인프라 기능을 정의합니다.
- `TokenProvider`: JWT 생성, 검증, 파싱 기능 정의
- `RefreshTokenRepository`: Refresh Token 저장, 조회, 삭제 (DB/Redis 연동)

### Step 3: 어댑터 구현 (Adapter Layer)

#### 1. Security Adapter (사용자 정보)
- **위치**: `adapter/security/details`
- **`SecurityMemberDTO`**: 엔티티 대신 SecurityContext에 저장할 최소 정보 객체 (Lazy Loading 방지).
- **`CustomUserDetails`**: `UserDetails` 구현체. `SecurityMemberDTO`를 내부에 가짐.
- **`CustomUserDetailsService`**: `MemberFinder`를 통해 회원을 조회하고 `CustomUserDetails` 반환.

#### 2. JWT Adapter (토큰 기술)
- **위치**: `adapter/security/jwt`
- **`JwtTokenProvider`**: `TokenProvider` 인터페이스 구현. jjwt 라이브러리 등을 사용해 실제 토큰 처리.

#### 3. Persistence Adapter (리프레시 토큰 저장소)
- **위치**: `adapter/jpa/auth` (또는 `adapter/redis/auth`)
- **멀티 디바이스 지원 전략**:
    - `Member` (1) : (N) `RefreshToken`
    - 저장 시 `(memberId, deviceId/userAgent, refreshToken)` 형태로 저장.
    - 재발급 시 요청된 Refresh Token과 DB에 저장된 토큰이 일치하는지 확인.

### Step 4: 비즈니스 로직 구현 (Application Service)

#### `AuthService` 구현
`LoginUseCase`, `TokenReissueUseCase`를 구현합니다. 순수 자바 코드로 작성합니다.

1.  **로그인 (`login`)**:
    - 이메일로 회원 조회 (`MemberFinder`)
    - 비밀번호 검증 (`PasswordEncoder`)
    - Access Token 생성 (`TokenProvider`)
    - Refresh Token 생성 및 저장 (`TokenProvider`, `RefreshTokenRepository`)
    - 결과 반환 (Tokens)

2.  **재발급 (`reissue`)**:
    - 요청된 Refresh Token 검증
    - 저장소에 해당 토큰이 존재하는지 확인
    - 유효하다면 새로운 Access Token 발급
    - (옵션) Refresh Token Rotation 적용 시 Refresh Token도 새로 발급 및 교체

---

## 3. 추천 패키지 구조

```text
src/main/java/hexa/chat/
├── application/
│   └── auth/
│       ├── AuthService.java (Class: Service Implementation)
│       ├── provided/ (Inbound Ports)
│       │   ├── LoginUseCase.java (Interface)
│       │   └── TokenReissueUseCase.java (Interface)
│       └── required/ (Outbound Ports)
│           ├── TokenProvider.java (Interface)
│           └── RefreshTokenRepository.java (Interface)
├── adapter/
│   ├── in/
│   │   └── web/
│   │       └── AuthController.java (Web Adapter)
│   ├── out/
│   │   └── persistence/
│   │       └── RefreshTokenJpaRepository.java (Persistence Adapter)
│   └── security/
│       ├── config/
│       │   └── SecurityConfig.java
│       ├── details/
│       │   ├── CustomUserDetails.java
│       │   ├── CustomUserDetailsService.java
│       │   └── SecurityMemberDTO.java
│       └── jwt/
│           ├── JwtTokenProvider.java (Impl of TokenProvider)
│           └── JwtAuthenticationFilter.java
└── domain/
    └── auth/
        └── RefreshToken.java (Domain Entity: token, memberId, deviceId, expiry)
```

---

## 4. 리프레시 토큰 관리 상세 정책 (Multi-Device)

1.  **식별**: 한 명의 유저가 여러 기기(PC, 모바일)에서 로그인할 수 있으므로, Refresh Token은 `memberId` 뿐만 아니라 **고유 식별값(Token 자체 혹은 DeviceId)**으로 구분되어야 합니다.
2.  **저장 구조 (예시)**:
    ```java
    class RefreshToken {
        Long id;
        Long memberId;
        String tokenValue;
        String deviceId; // 또는 User-Agent
        LocalDateTime expiryDate;
    }
    ```
3.  **로그아웃**:
    - 특정 기기 로그아웃: 해당 기기의 Refresh Token만 삭제.
    - 전체 로그아웃: 해당 `memberId`의 모든 Refresh Token 삭제.

---

## 5. 핵심 체크리스트
- [ ] `AuthService`에 Spring Security 의존성이 없는가? (순수성)
- [ ] Refresh Token이 회원당 여러 개 저장될 수 있는 구조인가? (멀티 디바이스)
- [ ] `CustomUserDetails`가 `Member` 엔티티를 직접 참조하지 않는가? (Lazy Loading 이슈 방지)
